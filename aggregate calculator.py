"""
aggregate calculator
calculates the exact masses of a series of aggregates of the provided formula within the specified m/z range

This calculator can output to a waters *.ref format file used for calibrations
"""

# positively charged molecule
pos = 'Na'

# negatively charged molecule
neg = 'I'

# ion mode being observed
mode = '-'

# range to calculate exact masses over
rng = [50,2000]

# whether to output calculated exact masses to a .ref file
output = False
# if output is to be generated, what is the instrument manufacturer
instrument = 'waters'

# keyword arguments for molecule
kw = {
#'dropmethod': 'threshold', # this increases calculation speed at the expense of accuracy
#'verbose': True,
}

if output is True:
    distributors = {
    'waters':{'comment':';','extension':'.ref'} # Waters instruments
    }
    
    fname = pos+neg
    if mode == '+':
        fname += '_pos_'
    elif mode == '-':
        fname += '_neg_'
    fname += str(rng[0])+'-'+str(rng[1])
    fname += '.ref'
    hndl = open(fname,'wt')
    hndl.write('; Calibration generated for aggregates of %s in the %s mode over the range %d-%d\n' %(pos+neg,mode,rng[0],rng[1]))
    hndl.write('; exact masses are estimated by the weighted average of all mass defects in the isotope pattern\n')
    hndl.write('; Calibration file generated by "aggregate calculator.py" written by Lars Yunker\n')

print 'Calculating aggregates of %s(n)%s(m) over m/z %d-%d' %(pos,neg,rng[0],rng[1])    
print 'n\tm\texact mass'
from _classes._Molecule import Molecule
for i in range(200):
    molpos = Molecule(pos, **kw) # positive molecule object
    molneg = Molecule(neg, **kw) # negative molecule object
    if mode == '+': # define integers
        n = i + 1
        m = i
    elif mode == '-':
        n = i
        m = i + 1
    if i == 0: # if this is the first iteration, set to exact mass of mode ion
        if n == 0:
            em = molneg.em
        elif m == 0:
            em = molpos.em
    else:
        molpos * n # multiply objects and recalculate
        molneg * m
        molpos + molneg # add together
        em = molpos.em # define exact mass
    
    if em > rng[1]:
        break
    if em >= rng[0]:
        print '%d\t%d\t%.7f' %(n,m,em)
        if output is True:
            #if i != 0:
            #    hndl.write('\n')
            hndl.write('{:<20}100\n'.format(em)) # formatted for masslynx *.ref files

if output is True:
    hndl.close()